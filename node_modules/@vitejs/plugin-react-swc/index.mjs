// src/index.ts
import { readFileSync } from "fs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";
<<<<<<< HEAD
import { createRequire } from "module";
import {
  transform
} from "@swc/core";

// ../common/refresh-utils.ts
var runtimePublicPath = "/@react-refresh";
var reactCompRE = /extends\s+(?:React\.)?(?:Pure)?Component/;
var refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
var preambleCode = `import { injectIntoGlobalHook } from "__BASE__${runtimePublicPath.slice(
  1
)}"
injectIntoGlobalHook(window);
window.$RefreshReg$ = () => {};
window.$RefreshSig$ = () => (type) => type;`;
var getPreambleCode = (base) => preambleCode.replace("__BASE__", base);
var avoidSourceMapOption = Symbol();
function addRefreshWrapper(code, map, pluginName, id, reactRefreshHost = "") {
  const hasRefresh = refreshContentRE.test(code);
  const onlyReactComp = !hasRefresh && reactCompRE.test(code);
  const normalizedMap = map === avoidSourceMapOption ? null : map;
  if (!hasRefresh && !onlyReactComp) return { code, map: normalizedMap };
  const avoidSourceMap = map === avoidSourceMapOption;
  const newMap = typeof normalizedMap === "string" ? JSON.parse(normalizedMap) : normalizedMap;
  let newCode = code;
  if (hasRefresh) {
    const refreshHead = removeLineBreaksIfNeeded(
      `let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.$RefreshReg$) {
    throw new Error(
      "${pluginName} can't detect preamble. Something is wrong."
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(${JSON.stringify(id)});
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}

`,
      avoidSourceMap
    );
    newCode = `${refreshHead}${newCode}

if (import.meta.hot && !inWebWorker) {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
`;
    if (newMap) {
      newMap.mappings = ";".repeat(16) + newMap.mappings;
    }
  }
  const sharedHead = removeLineBreaksIfNeeded(
    `import * as RefreshRuntime from "${reactRefreshHost}${runtimePublicPath}";
const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;

`,
    avoidSourceMap
  );
  newCode = `${sharedHead}${newCode}

if (import.meta.hot && !inWebWorker) {
  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
    RefreshRuntime.registerExportsForReactRefresh(${JSON.stringify(
    id
  )}, currentExports);
    import.meta.hot.accept((nextExports) => {
      if (!nextExports) return;
      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(${JSON.stringify(
    id
  )}, currentExports, nextExports);
      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
    });
  });
}
`;
  if (newMap) {
    newMap.mappings = ";;;" + newMap.mappings;
  }
  return { code: newCode, map: newMap };
}
function removeLineBreaksIfNeeded(code, enabled) {
  return enabled ? code.replace(/\n/g, "") : code;
}

// ../common/warning.ts
var silenceUseClientWarning = (userConfig) => ({
  rollupOptions: {
    onwarn(warning, defaultHandler) {
      var _a, _b;
      if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
        return;
      }
      if (warning.code === "SOURCEMAP_ERROR" && warning.message.includes("resolve original location") && warning.pos === 0) {
        return;
      }
      if ((_b = (_a = userConfig.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.onwarn) {
        userConfig.build.rollupOptions.onwarn(warning, defaultHandler);
      } else {
        defaultHandler(warning);
      }
    }
  }
});

// src/index.ts
=======
import {
  transform
} from "@swc/core";
import { createRequire } from "module";
var runtimePublicPath = "/@react-refresh";
var preambleCode = `import { injectIntoGlobalHook } from "__PATH__";
injectIntoGlobalHook(window);
window.$RefreshReg$ = () => {};
window.$RefreshSig$ = () => (type) => type;`;
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
var _dirname = typeof __dirname !== "undefined" ? __dirname : dirname(fileURLToPath(import.meta.url));
var resolve = createRequire(
  typeof __filename !== "undefined" ? __filename : import.meta.url
).resolve;
<<<<<<< HEAD
=======
var reactCompRE = /extends\s+(?:React\.)?(?:Pure)?Component/;
var refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
var _a, _b;
var isWebContainer = (_b = (_a = globalThis.process) == null ? void 0 : _a.versions) == null ? void 0 : _b["webcontainer"];
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
var react = (_options) => {
  let hmrDisabled = false;
  const options = {
    jsxImportSource: (_options == null ? void 0 : _options.jsxImportSource) ?? "react",
    tsDecorators: _options == null ? void 0 : _options.tsDecorators,
    plugins: (_options == null ? void 0 : _options.plugins) ? _options == null ? void 0 : _options.plugins.map((el) => [resolve(el[0]), el[1]]) : void 0,
    devTarget: (_options == null ? void 0 : _options.devTarget) ?? "es2020",
    parserConfig: _options == null ? void 0 : _options.parserConfig,
<<<<<<< HEAD
    reactRefreshHost: _options == null ? void 0 : _options.reactRefreshHost,
=======
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
    useAtYourOwnRisk_mutateSwcOptions: _options == null ? void 0 : _options.useAtYourOwnRisk_mutateSwcOptions
  };
  return [
    {
      name: "vite:react-swc:resolve-runtime",
      apply: "serve",
      enforce: "pre",
      // Run before Vite default resolve to avoid syscalls
      resolveId: (id) => id === runtimePublicPath ? id : void 0,
<<<<<<< HEAD
      load: (id) => id === runtimePublicPath ? readFileSync(join(_dirname, "refresh-runtime.js"), "utf-8").replace(
        /__README_URL__/g,
        "https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react-swc"
      ) : void 0
=======
      load: (id) => id === runtimePublicPath ? readFileSync(join(_dirname, "refresh-runtime.js"), "utf-8") : void 0
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
    },
    {
      name: "vite:react-swc",
      apply: "serve",
      config: () => ({
        esbuild: false,
<<<<<<< HEAD
        // NOTE: oxc option only exists in rolldown-vite
        oxc: false,
=======
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
        optimizeDeps: {
          include: [`${options.jsxImportSource}/jsx-dev-runtime`],
          esbuildOptions: { jsx: "automatic" }
        }
      }),
      configResolved(config) {
        if (config.server.hmr === false) hmrDisabled = true;
        const mdxIndex = config.plugins.findIndex(
          (p) => p.name === "@mdx-js/rollup"
        );
        if (mdxIndex !== -1 && mdxIndex > config.plugins.findIndex((p) => p.name === "vite:react-swc")) {
          throw new Error(
            "[vite:react-swc] The MDX plugin should be placed before this plugin"
          );
        }
<<<<<<< HEAD
=======
        if (isWebContainer) {
          config.logger.warn(
            "[vite:react-swc] SWC is currently not supported in WebContainers. You can use the default React plugin instead."
          );
        }
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
      },
      transformIndexHtml: (_, config) => [
        {
          tag: "script",
          attrs: { type: "module" },
<<<<<<< HEAD
          children: getPreambleCode(config.server.config.base)
=======
          children: preambleCode.replace(
            "__PATH__",
            config.server.config.base + runtimePublicPath.slice(1)
          )
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
        }
      ],
      async transform(code, _id, transformOptions) {
        const id = _id.split("?")[0];
        const refresh = !(transformOptions == null ? void 0 : transformOptions.ssr) && !hmrDisabled;
        const result = await transformWithOptions(
          id,
          code,
          options.devTarget,
          options,
          {
            refresh,
            development: true,
            runtime: "automatic",
            importSource: options.jsxImportSource
          }
        );
        if (!result) return;
        if (!refresh) return result;
<<<<<<< HEAD
        return addRefreshWrapper(
          result.code,
          result.map,
          "@vitejs/plugin-react-swc",
          id,
          options.reactRefreshHost
        );
=======
        const hasRefresh = refreshContentRE.test(result.code);
        if (!hasRefresh && !reactCompRE.test(result.code)) return result;
        const sourceMap = JSON.parse(result.map);
        sourceMap.mappings = ";;" + sourceMap.mappings;
        result.code = `import * as RefreshRuntime from "${runtimePublicPath}";

${result.code}`;
        if (hasRefresh) {
          sourceMap.mappings = ";;;;;;" + sourceMap.mappings;
          result.code = `if (!window.$RefreshReg$) throw new Error("React refresh preamble was not loaded. Something is wrong.");
const prevRefreshReg = window.$RefreshReg$;
const prevRefreshSig = window.$RefreshSig$;
window.$RefreshReg$ = RefreshRuntime.getRefreshReg("${id}");
window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;

${result.code}

window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;
`;
        }
        result.code += `
RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
  RefreshRuntime.registerExportsForReactRefresh("${id}", currentExports);
  import.meta.hot.accept((nextExports) => {
    if (!nextExports) return;
    const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate("${id}", currentExports, nextExports);
    if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
  });
});
`;
        return { code: result.code, map: sourceMap };
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
      }
    },
    options.plugins ? {
      name: "vite:react-swc",
      apply: "build",
      enforce: "pre",
      // Run before esbuild
      config: (userConfig) => ({
        build: silenceUseClientWarning(userConfig)
      }),
      transform: (code, _id) => transformWithOptions(_id.split("?")[0], code, "esnext", options, {
        runtime: "automatic",
        importSource: options.jsxImportSource
      })
    } : {
      name: "vite:react-swc",
      apply: "build",
      config: (userConfig) => ({
        build: silenceUseClientWarning(userConfig),
        esbuild: {
          jsx: "automatic",
          jsxImportSource: options.jsxImportSource,
          tsconfigRaw: {
            compilerOptions: { useDefineForClassFields: true }
          }
        }
      })
    }
  ];
};
var transformWithOptions = async (id, code, target, options, reactConfig) => {
  const decorators = (options == null ? void 0 : options.tsDecorators) ?? false;
  const parser = options.parserConfig ? options.parserConfig(id) : id.endsWith(".tsx") ? { syntax: "typescript", tsx: true, decorators } : id.endsWith(".ts") || id.endsWith(".mts") ? { syntax: "typescript", tsx: false, decorators } : id.endsWith(".jsx") ? { syntax: "ecmascript", jsx: true } : id.endsWith(".mdx") ? (
    // JSX is required to trigger fast refresh transformations, even if MDX already transforms it
    { syntax: "ecmascript", jsx: true }
  ) : void 0;
  if (!parser) return;
  let result;
  try {
    const swcOptions = {
      filename: id,
      swcrc: false,
      configFile: false,
      sourceMaps: true,
      jsc: {
        target,
        parser,
        experimental: { plugins: options.plugins },
        transform: {
          useDefineForClassFields: true,
          react: reactConfig
        }
      }
    };
    if (options.useAtYourOwnRisk_mutateSwcOptions) {
      options.useAtYourOwnRisk_mutateSwcOptions(swcOptions);
    }
    result = await transform(code, swcOptions);
  } catch (e) {
    const message = e.message;
    const fileStartIndex = message.indexOf("\u256D\u2500[");
    if (fileStartIndex !== -1) {
<<<<<<< HEAD
      const match = message.slice(fileStartIndex).match(/:(\d+):(\d+)\]/);
=======
      const match = message.slice(fileStartIndex).match(/:(\d+):(\d+)]/);
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
      if (match) {
        e.line = match[1];
        e.column = match[2];
      }
    }
    throw e;
  }
  return result;
};
<<<<<<< HEAD
=======
var silenceUseClientWarning = (userConfig) => ({
  rollupOptions: {
    onwarn(warning, defaultHandler) {
      var _a2, _b2;
      if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
        return;
      }
      if (warning.code === "SOURCEMAP_ERROR" && warning.message.includes("resolve original location") && warning.pos === 0) {
        return;
      }
      if ((_b2 = (_a2 = userConfig.build) == null ? void 0 : _a2.rollupOptions) == null ? void 0 : _b2.onwarn) {
        userConfig.build.rollupOptions.onwarn(warning, defaultHandler);
      } else {
        defaultHandler(warning);
      }
    }
  }
});
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
var index_default = react;
export {
  index_default as default
};
