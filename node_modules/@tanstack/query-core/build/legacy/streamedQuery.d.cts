<<<<<<< HEAD
import { F as QueryKey, _ as QueryFunctionContext, W as QueryFunction } from './hydration-n7FlH3vr.cjs';
=======
import { A as QueryKey, X as QueryFunctionContext, P as QueryFunction } from './hydration-BZgfn3GW.cjs';
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
import './removable.cjs';
import './subscribable.cjs';

/**
 * This is a helper function to create a query function that streams data from an AsyncIterable.
 * Data will be an Array of all the chunks received.
 * The query will be in a 'pending' state until the first chunk of data is received, but will go to 'success' after that.
 * The query will stay in fetchStatus 'fetching' until the stream ends.
 * @param queryFn - The function that returns an AsyncIterable to stream data from.
<<<<<<< HEAD
 * @param refetchMode - Defines how re-fetches are handled.
 * Defaults to `'reset'`, erases all data and puts the query back into `pending` state.
 * Set to `'append'` to append new data to the existing data.
 * Set to `'replace'` to write the data to the cache at the end of the stream.
 */
declare function streamedQuery<TQueryFnData = unknown, TQueryKey extends QueryKey = QueryKey>({ queryFn, refetchMode, }: {
    queryFn: (context: QueryFunctionContext<TQueryKey>) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>;
    refetchMode?: 'append' | 'reset' | 'replace';
=======
 * @param refetchMode - Defaults to 'reset', which replaces data when a refetch happens. Set to 'append' to append new data to the existing data.
 */
declare function streamedQuery<TQueryFnData = unknown, TQueryKey extends QueryKey = QueryKey>({ queryFn, refetchMode, }: {
    queryFn: (context: QueryFunctionContext<TQueryKey>) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>;
    refetchMode?: 'append' | 'reset';
>>>>>>> 3b008e380491e6ba2d199016330fcd7fa128de4c
}): QueryFunction<Array<TQueryFnData>, TQueryKey>;

export { streamedQuery };
